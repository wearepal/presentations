<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="custom.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="footer">
        <p>Topics in Computer Science</p>
      </div>
<div class="slides">

<section data-markdown><textarea data-template>
# Algorithmic fairness

by Oliver Thomas and Thomas Kehrenberg

<img src="images/sussex_logo.png" style="width: 15%; border: none;"/>
</textarea></section>

<section data-markdown><textarea data-template>
## Machine Learning

> ...using statistical techniques to give computer systems the ability to "learn"
  (e.g., progressively improve performance on a specific task)
  from data, without being explicitly programmed.
</textarea></section>

<section data-markdown><textarea data-template>
## Classification

- given some input $X$, predict a class label $Y \in \\{0, 1, ..., C-1\\}$
- $X$ is usually a **vector**
  - often with high number of dimensions, e.g. more than 1 million for a picture
- simplest case: **binary classification**, $Y \in \\{0, 1\\}$
  - for example: is there a hot dog in this picture ($Y=1$) or not ($Y=0$)?
</textarea></section>

<section data-markdown><textarea data-template>
## Classification

- we are looking to train a function $f$ that maps $X$ to $Y$
- the output is the prediction: $\hat{Y} = f(X)$
- we want $\hat{Y}$ to be as close as possible to the label $Y$
- $f$ can be implemented as
  - a neural network
  - an SVM
  - a logistic regression model
</textarea></section>

<section data-markdown><textarea data-template>
## Training data

- training data: a set of pairs $(x, y)$
  - input data $x$ with corresponding label $y$
- we are looking for model that works well on the training data
- if we make predictions on data that is *very different* from the training data,
  the model will perform badly
- problem if the training data does not describe reality well
</textarea></section>

<section data-markdown><textarea data-template>
## Where is machine learning used?

- hiring decisions
- bail decisions
- credit approval
- insurance premiums

<aside class="notes">
  Companies are already using or planning to use machine learning for these tasks.
</aside>
</textarea></section>

<section>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
But there are problems:
</section>

<section>
    <img class="stretch" src="images/pp_mb.png" title="Pro-Publica - Machine Bias"/>
</section>

<section>
    <img class="stretch" src="images/amazon.png" title="Amazon CV Screening"/>
</section>

<section data-markdown><textarea data-template>
## Algorithmic bias

- machine learning systems are making decisions that affect humans
- these decisions should be *fair*
- by default machine learning algorithms tend to be biased in some way
  - why?
</textarea></section>

<section data-markdown><textarea data-template>
## Algorithmic bias

The problem can be divided into <ins>two categories</ins>. Both types of bias can appear together.

- bias stemming from biased training data
- bias stemming from the algorithms themselves
</textarea></section>

<section data-markdown><textarea data-template>
# Biased training data
</textarea></section>

<section data-markdown><textarea data-template>
## Bias in, bias out

- Databases: GIGO
- ML: BIBO
  - the ML algorithm just learns what is in the training data
</textarea></section>

<section data-markdown><textarea data-template>
## Examples for bias

**Task**: generate description for images

![](./images/women_also_snowboard/title.png)
</textarea></section>

<section data-markdown><textarea data-template>
![](./images/women_also_snowboard/example1.png)
</textarea></section>

<section data-markdown><textarea data-template>
## Learning wrong features

The algorithm predicts the gender from the activity and not from looking at the person.

![](./images/women_also_snowboard/example2.png)
</textarea></section>

<section data-markdown><textarea data-template>
## Desired result

- what we would want is that the algorithm only looks at the person when predicting the gender
- if the gender is not recognizable from the picture, the algorithm should be "unsure"
</textarea></section>

<section data-markdown><textarea data-template>
## Biased data

- in the previous example, certain training examples were underrepresented
  - sampling bias
- other case: data is simply wrong
  - e.g. data was gathered by humans who just lied
</textarea></section>

<section data-markdown><textarea data-template>
## Enforcing a fair outcome

- no matter in what way the data is biased: we want to **enforce a fair outcome**
  - idea: just tell the algorithm that it should treat all groups in the same way
- question: **how do we define a fair outcome?**
  - really hard question
  - start with the simplest definition
</textarea></section>

<section data-markdown><textarea data-template>
## Example

- task: predict whether someone should be hired ($Y=1$) or not ($Y=0$)
- two races: <span style="color: blue">blue race</span> and <span style="color: green">green race</span>
  - blue: $S=0$, green: $S=1$
- in the training set: **20% of blue** applicants were hired, **50% of green** applicants were hired
</textarea></section>

<section data-markdown><textarea data-template>
## Statistical parity

$$
P(\hat{Y}=1 | S=0) = P(\hat{Y}=1 | S=1)
$$

- $\hat{Y} \in \\{0,1\\}, S \in \\{0,1\\}$
- $S$: sensitive attribute (for example gender, race)
- $\hat{Y}$: prediction

**meaning**: the probability to get a positive prediction is the same for each group
</textarea></section>

<section data-markdown><textarea data-template>
## Statistical parity

- concrete: when evaluating the algorithm on the test set, both groups ($S=0$ and $S=1$)
  should have the same number of positive predictions ($\hat{Y}=1$)
- in the hiring example from before: same percentage from both races will be hired (e.g. 30%)
</textarea></section>

<section data-markdown><textarea data-template>
(discuss trade-off with accuracy)

</textarea></section>

<section data-markdown><textarea data-template>
# Bias introduced by the ML algorithm
</textarea></section>

<section data-markdown><textarea data-template>
## Why would an ML algorithm introduce bias?

Consider again the hiring example:

- two features: SAT score and race (blue and green) of individuals

- task: predict if they should be hired ($y=1$) or not ($y=0$)

- composition of the dataset: 50% blue, 50% green. 20% of blue have $y=1$, 50% of green have $y=1$.
</textarea></section>

<section data-markdown><textarea data-template>
## Bias from algorithm

The dataset is heavily skewed but let's ignore that for now and just try to make accurate predictions for this dataset.
</textarea></section>

<section data-markdown><textarea data-template>
## Bias from algorithm

(Reminder: 20% of blue have $y=1$, 50% of green have $y=1$.)

A simple way to make relatively accurate predictions:
- for green individuals base the prediction on SAT
- for blue individuals ignore SAT score and always predict $y=0$

Result: up to 90% accuracy
</textarea></section>

<section data-markdown><textarea data-template>
## Bias from algorithm

- the dataset was already skewed but the algorithm's prediction are even more "unfair"
- this is because it's easier to just base the decision on race than to figure out the effect of the SAT
- this is an extreme case but similar things actually can happen
</textarea></section>

<section data-markdown><textarea data-template>
## Bias from algorithm

**What we don't want:** the algorithm "being lazy" in a subgroup

**What we want:** the algorithm should make equally good predictions for all subgroups

Criterion that enforces this: *Equality of Opportunity*
</textarea></section>

<section data-markdown><textarea data-template>
## Equality of Opportunity

$$
P(\hat{Y}=1 | S=0, Y=1) = P(\hat{Y}=1 | S=1, Y=1)
$$
$$
Y \in \{0,1\} \\
S \in \{0,1\}
$$
</textarea></section>

<section data-markdown><textarea data-template>
(discuss equality of opportunity)

(also mention Equalised Odds)
</textarea></section>

<section data-markdown><textarea data-template>
## Equalised Odds

$$
P(\hat{Y}=1 | S=0, Y=y) = P(\hat{Y}=1 | S=1, Y=y)
$$
$$
Y \in \{0,1\} \\
S \in \{0,1\}
$$
</textarea></section>

<!-- Border between Thomas stuff and Oliver stuff -->

<section>
  <section data-markdown><textarea data-template>
    ## Summary of Fairness Criteria

    - Demographic Parity
    - Equalised Odds
    - Equality of Opportunity
    - Calibration by Group
  </textarea></section>

  <section data-markdown><textarea data-template>
    ## Statistical Parity
    #### (**independence** based notion of fairness)

    $$
    P(\hat{Y}=1 | S=0) = P(\hat{Y}=1 | S=1)
    $$
    $$
    Y \in \{0,1\} \\
    S \in \{0,1\}
    $$ 
  </textarea></section>

  <section data-markdown><textarea data-template>
    ## Equalised Odds 
    #### (**separation** based notion of fairness)

    $$
    P(\hat{Y}=1 | S=0, Y=y) = P(\hat{Y}=1 | S=1, Y=y)
    $$
    $$
    Y \in \{0,1\} \\
    S \in \{0,1\}
    $$ 
  </textarea></section>

  <section data-markdown><textarea data-template>
    ## Equalised Opportunity 

    #### (**separation** based notion of fairness)

    $$
    P(\hat{Y}=1 | S=0, Y=1) = P(\hat{Y}=1 | S=1, Y=1)
    $$
    $$
    Y \in \{0,1\} \\
    S \in \{0,1\}
    $$ 
  </textarea></section>

  <section data-markdown><textarea data-template>
    ## Calibration by Group 
    #### (**sufficiency** based notion of fairness)

    $$
    P(Y=1 | \hat{Y}=\hat{y}, S=s) = \hat{y}
    $$
    $$
    \hat{Y} \in \[0...1\] \\
    S \in \{0,1\}
    $$ 
  </textarea></section>
</section>

<section data-markdown><textarea data-template>
    Let's have all the fairness!
  
    If we are fair with regards to all notions of fair, then we're fair... right?
</textarea></section>

<section data-markdown><textarea data-template>
    Independence based fairness (i.e. Statistical Parity)

    $$
    \hat{Y} \perp S
    $$

    Separation based fairness (i.e. Equalized Odds/Opportunity)

    $$
    \hat{Y} \perp S | Y
    $$

    For both to hold, then either $S \perp Y$, our data is fair, or $\hat{Y} \perp Y$, we have a random predictor.

    Similarly, Sufficiency cannot hold with either notion of fairness.
</textarea></section>

<section data-markdown><textarea data-template>
## How to enforce fairness?

Fairness constraints can be added pre, during or post training.

Pre-training examples
- Zemel Fair Representations
- Beutel Adversarial Representation
- Quadrianto Fair Interpretable Representations
- Feldman
</textarea></section>

<section data-markdown><textarea data-template>
During Training
- Zafar's methods
- Zhang
- Kehrenberg Fair GP

Post Training
- Hardt Recalibrating
</textarea></section>

<section data-markdown><textarea data-template>

</textarea></section>

<section data-markdown><textarea data-template>
  Popular approach is to add produce a "fair" representation. Consider that we have 2 roles, a data vendor, who is charge of collecting the data and preparing it. Our other role is a data user, someone who will be making predictions based on our data. 

  The data vendor is concerned that the data user may be using their data to make unfair decisions. So the data vendor decides to learn a new, fair representation.
</textarea></section>

<section data-markdown><textarea data-template>
The state-of-the-art method a fair representation this is to use an *adversarial* network, using a "Gradient-Reversal Layer" from Ganin et al.

![](./images/adversarial.svg)
</textarea></section>

<section>
  <h3>Problems with doing this?</h3>
  <section><h4>Any Ideas?</h4></section>
<section>
  <h4>What does this representation mean?</h4>

  <p>The learned representation is uninterpretable by default. Recently Quadrianto et al constrained the representation to be in the same same as the input so that we could look at what changed</p>
  </section>
<section>
  <h4>What if the vendor data user decides to be fair as well?</h4>

  <p>Referred to as "fair pipelines". Work has only just begun exploring these. Current research shows that these don't work (at the moment!)</p>
</section>
</section>


</div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        markdown: {
          smartypants: true,
          gfm: true
        },
        math: {
          config: 'TeX-AMS_HTML-full'
        },
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          // { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/math/math.js', async: true }
        ],
        // The "normal" size of the presentation, aspect ratio will be preserved when the presentation is scaled to fit different resolutions
        width: 1120, // default 960
        height: 700,
        // Factor of the display size that should remain empty around the content
        margin: 0.04,
        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,
        maxScale: 2.0,
        // Help the user learn the controls by providing hints, for example by bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,
        // Display a presentation progress bar
        progress: false,
        // Display the page number of the current slide
        slideNumber: 'c/t',
        // Push each slide change to the browser history
        history: true,
        // Enable the slide overview mode
        overview: true,
        // Vertical centering of slides
        center: false,
        // Turns fragments on and off globally
        fragments: true,
        // whether the presentation is running in an embedded mode, i.e. contained within a limited portion of the screen
        embedded: false,
        // whether speaker notes should be visible to all viewers
        showNotes: false,
        // Enable slide navigation via mouse wheel
        mouseWheel: false,
        // Hides the address bar on mobile devices
        hideAddressBar: true,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'none', // none/fade/slide/convex/concave/zoom
        // Number of slides away from the current that are visible in overview
        viewDistance: 3,
      });
    </script>
  </body>
</html>
